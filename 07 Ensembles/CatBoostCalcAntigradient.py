import numpy as np

# –ò—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
X = np.array([[1], [2], [3], [4]]).astype(float)
y = np.array([1.0, 2.0, 3.0, 4.0])

# ---------- –®–∞–≥ 0: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è F0 ----------
F0 = np.mean(y)  # = 2.5
print(f"üîπ F0 (–≥–ª–æ–±–∞–ª—å–Ω–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞) = {F0}")

# –í CatBoost —ç—Ç–æ –µ–¥–∏–Ω–æ–µ –Ω–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–ª—è –í–°–ï–• –æ–±—ä–µ–∫—Ç–æ–≤
F_current = np.full_like(y, F0)  # [2.5, 2.5, 2.5, 2.5]

# ---------- –®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –ø–µ—Ä–≤–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ ----------
# –§–∏–∫—Å–∏—Ä—É–µ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫—É (–≤ —Ä–µ–∞–ª—å–Ω–æ–º CatBoost ‚Äî —Å–ª—É—á–∞–π–Ω–∞—è)
permutation = np.arange(len(y))  # [0, 1, 2, 3]

# –í CatBoost –î–û –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ –¥–µ—Ä–µ–≤–∞ —É –Ω–∞—Å –ù–ï–¢ –Ω–∏–∫–∞–∫–∏—Ö –¥–µ—Ä–µ–≤—å–µ–≤.
# –ü–æ—ç—Ç–æ–º—É –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–∞—è –º–æ–¥–µ–ª—å F^(i) –¥–ª—è –ª—é–±–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ ‚Äî —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ F0.

print("\nüîπ –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∞–Ω—Ç–∏–≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤ –Ω–∞ –ü–ï–†–í–û–ô –∏—Ç–µ—Ä–∞—Ü–∏–∏:")
ordered_residuals = np.zeros_like(y)

for i in range(len(permutation)):
    obj_idx = permutation[i]  # –∏–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –æ–±—ä–µ–∫—Ç–∞
    
    # === –ö–õ–Æ–ß–ï–í–û–ô –ú–û–ú–ï–ù–¢ ===
    # –ù–∞ –ø–µ—Ä–≤–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —É –Ω–∞—Å –µ—â—ë –ù–ï–¢ –¥–µ—Ä–µ–≤—å–µ–≤.
    # –ü–æ—ç—Ç–æ–º—É F^(i) = F0 ‚Äî –¥–∞–∂–µ –µ—Å–ª–∏ –º—ã "–æ–≥—Ä–∞–Ω–∏—á–µ–Ω—ã" –ø—Ä–µ–¥—ã–¥—É—â–∏–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏.
    F_i = F0  # ‚Üê –∏–º–µ–Ω–Ω–æ –∑–¥–µ—Å—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≥–ª–æ–±–∞–ª—å–Ω–∞—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞!
    
    # –ê–Ω—Ç–∏–≥—Ä–∞–¥–∏–µ–Ω—Ç –¥–ª—è MSE: r = y - F
    residual = y[obj_idx] - F_i
    ordered_residuals[obj_idx] = residual
    
    print(f"  –û–±—ä–µ–∫—Ç {obj_idx}: F^(i) = {F_i:.1f}, y = {y[obj_idx]:.1f}, –æ—Å—Ç–∞—Ç–æ–∫ = {residual:.1f}")

print(f"\n‚úÖ –ê–Ω—Ç–∏–≥—Ä–∞–¥–∏–µ–Ω—Ç—ã (–æ—Å—Ç–∞—Ç–∫–∏) –Ω–∞ –ø–µ—Ä–≤–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏: {ordered_residuals}")
print(f"‚úÖ –í –æ–±—ã—á–Ω–æ–º –±—É—Å—Ç–∏–Ω–≥–µ –æ–Ω–∏ –ë–´–õ–ò –ë–´ –¢–ï –ñ–ï –°–ê–ú–´–ï: {y - F0}\n\n")



from sklearn.tree import DecisionTreeRegressor

# –î–æ–ø—É—Å—Ç–∏–º, –º—ã —É–∂–µ –ø–æ—Å—Ç—Ä–æ–∏–ª–∏ –ø–µ—Ä–≤–æ–µ –¥–µ—Ä–µ–≤–æ –Ω–∞ –æ—Å—Ç–∞—Ç–∫–∞—Ö
tree = DecisionTreeRegressor(max_depth=1, random_state=0)
tree.fit(X, ordered_residuals)

# –ü–æ–ª—É—á–∏–º –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–µ—Ä–µ–≤–∞
h1_pred = tree.predict(X)
print(f"\nüîπ –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ –¥–µ—Ä–µ–≤–∞ h1(x): {h1_pred}")

# Learning rate
nu = 1.0

# –¢–µ–ø–µ—Ä—å –ø–æ–ª–Ω–∞—è –º–æ–¥–µ–ª—å –ø–æ—Å–ª–µ 1 –∏—Ç–µ—Ä–∞—Ü–∏–∏:
F_after_1 = F0 + nu * h1_pred
print(f"üîπ –ü–æ–ª–Ω–∞—è –º–æ–¥–µ–ª—å F1(x) = F0 + h1(x): {F_after_1}")

# ---------- –í–¢–û–†–ê–Ø –ò–¢–ï–†–ê–¶–ò–Ø: —Ç–µ–ø–µ—Ä—å F^(i) != F0 ----------
print("\nüîπ –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∞–Ω—Ç–∏–≥—Ä–∞–¥–∏–µ–Ω—Ç–æ–≤ –Ω–∞ –í–¢–û–†–û–ô –∏—Ç–µ—Ä–∞—Ü–∏–∏ (CatBoost):")

ordered_residuals_iter2 = np.zeros_like(y)

for i in range(len(permutation)):
    obj_idx = permutation[i]
    
    if i == 0:
        # –ù–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ ‚Üí –∏—Å–ø–æ–ª—å–∑—É–µ–º F0
        F_i = F0
    else:
        # –ë–µ—Ä—ë–º –¢–û–õ–¨–ö–û –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –æ–±—ä–µ–∫—Ç—ã
        prev_indices = permutation[:i]
        
        # –°—Ç—Ä–æ–∏–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—É—é –º–æ–¥–µ–ª—å, –æ–±—É—á–µ–Ω–Ω—É—é –¢–û–õ–¨–ö–û –Ω–∞ prev_indices
        # (–≤ —É–ø—Ä–æ—â—ë–Ω–Ω–æ–º –≤–∏–¥–µ: –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—è–µ–º –¥–µ—Ä–µ–≤–æ, –Ω–æ —Ç–æ–ª—å–∫–æ –∫ –ø–æ–¥–≤—ã–±–æ—Ä–∫–µ)
        # –í —Ä–µ–∞–ª—å–Ω–æ–º CatBoost –¥–µ—Ä–µ–≤–æ –ø–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è, –Ω–æ –∑–¥–µ—Å—å –∏–º–∏—Ç–∏—Ä—É–µ–º —ç—Ñ—Ñ–µ–∫—Ç:
        F_i = F0 + nu * np.mean(h1_pred[prev_indices])  # —É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –∏–º–∏—Ç–∞—Ü–∏—è
        
    residual = y[obj_idx] - F_i
    ordered_residuals_iter2[obj_idx] = residual
    print(f"  –û–±—ä–µ–∫—Ç {obj_idx}: F^(i) = {F_i:.2f}, y = {y[obj_idx]:.1f}, –æ—Å—Ç–∞—Ç–æ–∫ = {residual:.2f}")

print(f"\n‚ö†Ô∏è  –û—Å—Ç–∞—Ç–∫–∏ –Ω–∞ –≤—Ç–æ—Ä–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞!")
print(f"  –í –æ–±—ã—á–Ω–æ–º –±—É—Å—Ç–∏–Ω–≥–µ: {y - F_after_1}")